<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Using mwcsr package</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Using mwcsr package</h1>


<div id="TOC">
<ul>
<li><a href="#installation">Installation</a></li>
<li><a href="#quick-start">Quick start</a></li>
<li><a href="#supported-problem-types">Supported problem types</a>
<ul>
<li><a href="#simple-mwcs">Simple MWCS</a></li>
<li><a href="#budget-mwcs">Budget MWCS</a></li>
<li><a href="#generalized-mwcs-gmwcs">Generalized MWCS (GMWCS)</a></li>
<li><a href="#signal-generalized-mwcs-sgmwcs">Signal generalized MWCS
(SGMWCS)</a></li>
</ul></li>
<li><a href="#supported-solvers">Supported solvers</a>
<ul>
<li><a href="#rmwcs-solver">Rmwcs solver</a></li>
<li><a href="#rnc-solver">Rnc solver</a></li>
<li><a href="#simulated-annealing-solver">Simulated annealing
solver</a></li>
<li><a href="#java-based-virgo-solver">Java-based Virgo solver</a></li>
<li><a href="#scip-jack-solver">SCIP-jack solver</a></li>
</ul></li>
<li><a href="#integration-with-bionet">Integration with BioNet</a></li>
</ul>
</div>

<p><code>mwcsr</code> is an R package to solve maximum weight connected
subgraph (MWCS) problem and its variants. The package implements and
provides an interface to several solvers: both exact and heuristic.</p>
<div id="installation" class="section level2">
<h2>Installation</h2>
<p><code>mwcsr</code> can be installed from GitHub repository using
<code>devtools</code> package:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(devtools)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">install_github</span>(<span class="st">&quot;ctlab/mwcsr&quot;</span>)</span></code></pre></div>
</div>
<div id="quick-start" class="section level2">
<h2>Quick start</h2>
<p>Load <code>mwcsr</code>, as well as <code>igraph</code> package,
which contains functions for graph manipulations.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mwcsr)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(igraph)</span></code></pre></div>
<p>Let’s load an example instance of MWCS problem. The instance is a
simple <code>igraph</code> object with <code>weight</code> vertex
attribute.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">&quot;mwcs_example&quot;</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(mwcs_example)</span></code></pre></div>
<pre><code>## IGRAPH f86c56f UN-- 194 209 -- 
## + attr: name (v/c), label (v/c), weight (v/n), label (e/c)
## + edges from f86c56f (vertex names):
##  [1] C00022_2--C00024_0  C00022_0--C00024_1  C00025_0--C00026_0 
##  [4] C00025_1--C00026_1  C00025_2--C00026_2  C00025_4--C00026_4 
##  [7] C00025_7--C00026_7  C00024_1--C00033_0  C00024_0--C00033_1 
## [10] C00022_0--C00041_0  C00022_1--C00041_1  C00022_2--C00041_2 
## [13] C00036_0--C00049_0  C00036_1--C00049_1  C00036_2--C00049_2 
## [16] C00036_4--C00049_4  C00037_1--C00065_0  C00037_0--C00065_1 
## [19] C00022_0--C00074_5  C00022_1--C00074_6  C00022_2--C00074_7 
## [22] C00024_0--C00083_0  C00024_1--C00083_1  C00026_1--C00091_0 
## + ... omitted several edges</code></pre>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(<span class="fu">V</span>(mwcs_example)<span class="sc">$</span>weight)</span></code></pre></div>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
## -0.7379 -0.7379  1.9294  5.9667  7.2931 38.1546</code></pre>
<p>Now let us initialize a heuristic relax-and-cut MWCS solver
(Alvarez-Miranda and Sinnl, 2017):</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>rcsolver <span class="ot">&lt;-</span> <span class="fu">rmwcs_solver</span>()</span></code></pre></div>
<p>Now we can use this solver to solve the example instance:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>m <span class="ot">&lt;-</span> <span class="fu">solve_mwcsp</span>(rcsolver, mwcs_example)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(m<span class="sc">$</span>graph)</span></code></pre></div>
<pre><code>## IGRAPH 6495ccc UN-- 162 164 -- 
## + attr: name (v/c), label (v/c), weight (v/n)
## + edges from 6495ccc (vertex names):
##  [1] C00022_0--C00024_1  C00022_0--C00041_0  C00022_0--C00074_5 
##  [4] C00022_0--C00149_0  C00022_1--C00041_1  C00022_1--C00074_6 
##  [7] C00022_1--C00149_2  C00022_2--C00024_0  C00022_2--C00041_2 
## [10] C00022_2--C00074_7  C00022_2--C00149_1  C00024_0--C00033_1 
## [13] C00024_0--C00222_0  C00024_1--C00033_0  C00024_1--C00222_2 
## [16] C00025_0--C00026_0  C00025_1--C00026_1  C00025_2--C00026_2 
## [19] C00025_4--C00026_4  C00025_7--C00026_7  C00026_0--C00091_1 
## [22] C00026_0--C00311_1  C00026_1--C00091_0  C00026_1--C00311_0 
## + ... omitted several edges</code></pre>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(m<span class="sc">$</span>weight)</span></code></pre></div>
<pre><code>## [1] 1178.432</code></pre>
</div>
<div id="supported-problem-types" class="section level2">
<h2>Supported problem types</h2>
<p>Supported MWCS variants are:</p>
<ul>
<li>classic (simple) MWCS, where only vertices are weighted;</li>
<li>generalized MWCS (GMWCS), where both vertices and edges are
weighted;</li>
<li>signal generalized MWCS (SGMWCS), where both vertices and edges are
marked with weighted “signals”, and a weight of a subgraph is calculated
as a sum of weights of its unique signals.</li>
</ul>
<p>In <code>mwcsr</code>, instances of all of the above problems are
represented by an <code>igraph</code> object with certain specified
attributes. The validity and the type of the instance can be checked
using <code>get_instance_type</code> function, for example:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">get_instance_type</span>(mwcs_example)</span></code></pre></div>
<pre><code>## $type
## [1] &quot;MWCS&quot;
## 
## $valid
## [1] TRUE</code></pre>
<div id="simple-mwcs" class="section level3">
<h3>Simple MWCS</h3>
<p>Simple maximum weight connected subgraph (MWCS) problem can be
defined as follows. Let <span class="math inline">\(G = (V, E)\)</span>
be an undirected graph and <span class="math inline">\(\omega : V
\rightarrow \mathbb{R}\)</span> is a weight function defined on the
vertices. Then MWCS problem consists in finding a connected subgraph
<span class="math inline">\(\widetilde{G} = (\widetilde{V},
\widetilde{E})\)</span> with a maximal total sum of vertex weights:</p>
<p><span class="math display">\[\Omega(\widetilde{G}) = \sum_{v \in
\widetilde{V}} \omega(v) \rightarrow max.\]</span></p>
<p>An important property of MWCS is that solution can always be
represented as a tree.</p>
<p>In <code>mwcsr</code> an MWCS instance is defined as an
<code>igraph</code> with <code>weight</code> vertex attribute (and
without <code>weight</code> edge attribute).</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>mwcs_example</span></code></pre></div>
<pre><code>## IGRAPH f86c56f UN-- 194 209 -- 
## + attr: name (v/c), label (v/c), weight (v/n), label (e/c)
## + edges from f86c56f (vertex names):
##  [1] C00022_2--C00024_0  C00022_0--C00024_1  C00025_0--C00026_0 
##  [4] C00025_1--C00026_1  C00025_2--C00026_2  C00025_4--C00026_4 
##  [7] C00025_7--C00026_7  C00024_1--C00033_0  C00024_0--C00033_1 
## [10] C00022_0--C00041_0  C00022_1--C00041_1  C00022_2--C00041_2 
## [13] C00036_0--C00049_0  C00036_1--C00049_1  C00036_2--C00049_2 
## [16] C00036_4--C00049_4  C00037_1--C00065_0  C00037_0--C00065_1 
## [19] C00022_0--C00074_5  C00022_1--C00074_6  C00022_2--C00074_7 
## [22] C00024_0--C00083_0  C00024_1--C00083_1  C00026_1--C00091_0 
## + ... omitted several edges</code></pre>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(<span class="fu">V</span>(mwcs_example)<span class="sc">$</span>weight)</span></code></pre></div>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
## -0.7379 -0.7379  1.9294  5.9667  7.2931 38.1546</code></pre>
</div>
<div id="budget-mwcs" class="section level3">
<h3>Budget MWCS</h3>
<p>Budget MWCS is a slight modification of the original problem. While
the objective function remains the same, an additional constraint is
introduced. In this problem nonnegative values called budget costs are
assigned to vertices. The sum of budget costs of the vertices in the
solution is then constrained to not exceed a predefined budget.</p>
<p>More formally, let <span class="math inline">\(c: V \rightarrow
R^+\)</span> be the function of the budget costs. <span class="math inline">\(B \in R^+\)</span> is a budget of the problem. In
this terms Budget MWCS is defined as a problem where the following
conditions are satisfied:</p>
<p><span class="math display">\[
\Omega(\widetilde{G}) = \sum\limits_{v \in \widetilde{V}} \omega(v)
\rightarrow max.\\
\text{subject to} \sum\limits_{v \in \widetilde{V}} c(v) \leq B
\]</span></p>
<p>In <code>mwcsr</code> a Budget MWCS instance is an
<code>igraph</code> object with <code>weight</code> vertex attribute as
in original MWCS problem and additional <code>budget_cost</code> vertex
attribute. Value of the budget not the part of the instance itself but
rather a parameter to be passed to a function that solves an
instance.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>budget_mwcs_example <span class="ot">&lt;-</span> mwcs_example</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">42</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="fu">V</span>(budget_mwcs_example)<span class="sc">$</span>budget_cost <span class="ot">&lt;-</span> <span class="fu">runif</span>(<span class="fu">vcount</span>(budget_mwcs_example))</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="fu">get_instance_type</span>(budget_mwcs_example)</span></code></pre></div>
<pre><code>## $type
## [1] &quot;Budget MWCS&quot;
## 
## $valid
## [1] TRUE</code></pre>
</div>
<div id="generalized-mwcs-gmwcs" class="section level3">
<h3>Generalized MWCS (GMWCS)</h3>
<p>Generalized MWCS (GMWCS) is similar to MWCS, but edges are also
weighted. More formally, let <span class="math inline">\(G = (V,
E)\)</span> be an undirected graph and <span class="math inline">\(\omega : (V \cup E) \rightarrow
\mathbb{R}\)</span> is a weight function defined on the vertices and the
edges. Then GMWCS problem consists in finding a connected subgraph <span class="math inline">\(\widetilde{G} = (\widetilde{V},
\widetilde{E})\)</span> with a a maximal total sum of vertex and edge
weights:</p>
<p><span class="math display">\[
\Omega(\widetilde{G}) = \sum_{v \in \widetilde{V}} \omega(v) +
\sum_{e \in \widetilde{E}} \omega(e) \rightarrow max.
\]</span></p>
<p>An important consequence of edge weights is that the optimal solution
can contain cycles.</p>
<p>A GMWCS instance is defined as an <code>igraph</code> with
<code>weight</code> attribute defined for both vertices and edges.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(gmwcs_example)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>gmwcs_example</span></code></pre></div>
<pre><code>## IGRAPH f86c56f UNW- 194 209 -- 
## + attr: name (v/c), label (v/c), weight (v/n), label (e/c), weight
## | (e/n)
## + edges from f86c56f (vertex names):
##  [1] C00022_2--C00024_0 C00022_0--C00024_1 C00025_0--C00026_0 C00025_1--C00026_1
##  [5] C00025_2--C00026_2 C00025_4--C00026_4 C00025_7--C00026_7 C00024_1--C00033_0
##  [9] C00024_0--C00033_1 C00022_0--C00041_0 C00022_1--C00041_1 C00022_2--C00041_2
## [13] C00036_0--C00049_0 C00036_1--C00049_1 C00036_2--C00049_2 C00036_4--C00049_4
## [17] C00037_1--C00065_0 C00037_0--C00065_1 C00022_0--C00074_5 C00022_1--C00074_6
## [21] C00022_2--C00074_7 C00024_0--C00083_0 C00024_1--C00083_1 C00026_1--C00091_0
## [25] C00042_2--C00091_0 C00026_0--C00091_1 C00042_1--C00091_1
## + ... omitted several edges</code></pre>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(<span class="fu">V</span>(gmwcs_example)<span class="sc">$</span>weight)</span></code></pre></div>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
## -0.7379 -0.7379  1.9294  5.9667  7.2931 38.1546</code></pre>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(<span class="fu">E</span>(gmwcs_example)<span class="sc">$</span>weight)</span></code></pre></div>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
## -1.2715 -0.5762 -0.1060  0.5452  1.0458  8.5829</code></pre>
</div>
<div id="signal-generalized-mwcs-sgmwcs" class="section level3">
<h3>Signal generalized MWCS (SGMWCS)</h3>
<p>The signal generalized MWCS (SGMWCS) variant continues to generalize
MWCS problem and introduces a concept of <em>signals</em>. Instead of
specifying vertex and edge weights directly, the weights are defined for
a set of signals, and vertices and edges are marked with these signals.
The difference from GMWCS is that the signals can be repeated in the
graph, while the weight of the subgraph is defined as a sum of weights
of its unique signals.</p>
<p>Formally, let <span class="math inline">\(G = (V, E)\)</span> be an
undirected graph, <span class="math inline">\(S\)</span> – a set of
signlas with weights <span class="math inline">\(\omega: S \rightarrow
\mathbb{R}\)</span>, and <span class="math inline">\(\sigma: (V \cup E)
\rightarrow 2^S\)</span> – markings of the vertices and edges with
signals. An SGMWCS problem consists in finding a connected subgraph,
with a maximal total sum of its unique signals:</p>
<p><span class="math display">\[
\Omega(\widetilde{G}) =
    \sum_{s \in \sigma(\widetilde{V} \cup \widetilde{E})} \omega(s)
\rightarrow max,
\]</span> where <span class="math inline">\(\sigma(\widetilde{V} \cup
\widetilde{E}) = \bigcup_{x \in (\widetilde{V} \cup \widetilde{E})}
\sigma(x)\)</span>.</p>
<p>SGMWCS instances can arise when the data, from which the weights are
inferred, map to the graph ambigously. For example, when m/z peak from
mass-spectrometry data is assigned to multiple isomer metabolites, or
when the same enzyme catalyze multiple reactions, and so on.
Practically, it is usually assumed that the signals with negative
weights are not repeated.</p>
<p>An SGMWCS is represented as an <code>igraph</code> object, with
<code>signal</code> attribute defined for both vertices and edges and a
<code>signals</code> attribute defined for the graph, containing the
signal weights. Specification of multiple signals per node or edge is
not yet supported.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">&quot;sgmwcs_example&quot;</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>sgmwcs_example</span></code></pre></div>
<pre><code>## IGRAPH f86c56f UN-- 194 209 -- 
## + attr: signals (g/n), name (v/c), label (v/c), signal (v/c), label
## | (e/c), signal (e/c)
## + edges from f86c56f (vertex names):
##  [1] C00022_2--C00024_0 C00022_0--C00024_1 C00025_0--C00026_0 C00025_1--C00026_1
##  [5] C00025_2--C00026_2 C00025_4--C00026_4 C00025_7--C00026_7 C00024_1--C00033_0
##  [9] C00024_0--C00033_1 C00022_0--C00041_0 C00022_1--C00041_1 C00022_2--C00041_2
## [13] C00036_0--C00049_0 C00036_1--C00049_1 C00036_2--C00049_2 C00036_4--C00049_4
## [17] C00037_1--C00065_0 C00037_0--C00065_1 C00022_0--C00074_5 C00022_1--C00074_6
## [21] C00022_2--C00074_7 C00024_0--C00083_0 C00024_1--C00083_1 C00026_1--C00091_0
## [25] C00042_2--C00091_0 C00026_0--C00091_1 C00042_1--C00091_1
## + ... omitted several edges</code></pre>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(<span class="fu">V</span>(sgmwcs_example)<span class="sc">$</span>signal)</span></code></pre></div>
<pre><code>##  chr [1:194] &quot;s1&quot; &quot;s1&quot; &quot;s1&quot; &quot;s2&quot; &quot;s3&quot; &quot;s4&quot; &quot;s4&quot; &quot;s4&quot; &quot;s4&quot; &quot;s4&quot; &quot;s5&quot; &quot;s5&quot; ...</code></pre>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(<span class="fu">E</span>(sgmwcs_example)<span class="sc">$</span>signal)</span></code></pre></div>
<pre><code>##  chr [1:209] &quot;s103&quot; &quot;s104&quot; &quot;s105&quot; &quot;s106&quot; &quot;s107&quot; &quot;s108&quot; &quot;s109&quot; &quot;s110&quot; &quot;s110&quot; ...</code></pre>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(sgmwcs_example<span class="sc">$</span>signals)</span></code></pre></div>
<pre><code>##        s1        s2        s3        s4        s5        s6 
##  5.008879 -0.737898 -0.737898 20.112627 19.890279  2.069292</code></pre>
<div id="constructing-sgmwcs-instances" class="section level4">
<h4>Constructing SGMWCS instances</h4>
<p>Sometimes, construction of SGMWCS instances can be simplified using
<code>normalize_sgmwcs_instance</code> function.</p>
<p>Let consider an example graph obtained from <a href="https://github.com/ctlab/gatom">gatom</a> package.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">&quot;gatom_example&quot;</span>)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(gatom_example)</span></code></pre></div>
<pre><code>## IGRAPH f86c56f UNW- 194 209 -- 
## + attr: name (v/c), metabolite (v/c), element (v/c), label (v/c), url
## | (v/c), pval (v/n), origin (v/n), HMDB (v/c), log2FC (v/n), baseMean
## | (v/n), logPval (v/n), signal (v/c), signalRank (v/n), score (v/n),
## | weight (v/n), label (e/c), pval (e/n), origin (e/n), RefSeq (e/c),
## | gene (e/c), enzyme (e/c), reaction_name (e/c), reaction_equation
## | (e/c), url (e/c), reaction (e/c), rpair (e/c), log2FC (e/n), baseMean
## | (e/n), logPval (e/n), signal (e/c), signalRank (e/n), score (e/n),
## | weight (e/n)
## + edges from f86c56f (vertex names):
## [1] C00022_2--C00024_0 C00022_0--C00024_1 C00025_0--C00026_0 C00025_1--C00026_1
## + ... omitted several edges</code></pre>
<p>In this graph, the <code>signals</code> graph attributed is absent
with weights specified directly as vertex or edge attributes along with
<code>signal</code> attributes, which is a very practical intermediate
representation. However, it is recognized as a GMWCS instance:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="fu">get_instance_type</span>(gatom_example)</span></code></pre></div>
<pre><code>## $type
## [1] &quot;GMWCS&quot;
## 
## $valid
## [1] TRUE</code></pre>
<p>Let convert this representation into a valid SGMWCS instance using
<code>normalize_sgmwcs_instance</code> function:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>gatom_instance <span class="ot">&lt;-</span> <span class="fu">normalize_sgmwcs_instance</span>(gatom_example)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="fu">get_instance_type</span>(gatom_instance)</span></code></pre></div>
<pre><code>## $type
## [1] &quot;SGMWCS&quot;
## 
## $valid
## [1] TRUE</code></pre>
<p>And let call the same function with explicit arguments:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>gatom_instance <span class="ot">&lt;-</span> <span class="fu">normalize_sgmwcs_instance</span>(gatom_example,</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>                                            <span class="at">nodes.weight.column =</span> <span class="st">&quot;weight&quot;</span>,</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>                                            <span class="at">edges.weight.column =</span> <span class="st">&quot;weight&quot;</span>,</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>                                            <span class="at">nodes.group.by =</span> <span class="st">&quot;signal&quot;</span>,</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>                                            <span class="at">edges.group.by =</span> <span class="st">&quot;signal&quot;</span>, </span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>                                            <span class="at">group.only.positive =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<p>The function does the following:</p>
<ol style="list-style-type: decimal">
<li>It extracts signal weights from the specified columns.
<code>NULL</code> can be specified as a value of
<code>nodes.group.by</code> or <code>edges.group.by</code> if there are
no corresponding signals in the data, in which case zero signals will be
created.</li>
<li>It splits input signals with negative weights into multiple unique
signals, unless <code>group.only.positive</code> is set to
<code>FALSE</code>.</li>
</ol>
</div>
</div>
</div>
<div id="supported-solvers" class="section level2">
<h2>Supported solvers</h2>
<p>Currently, four solvers are supported:</p>
<ul>
<li>heuristic relax-and-cut solver <code>rmwcs_solver</code> for MWCS
and Budget MWCS;</li>
<li>heuristic relax-and-cut solver <code>rnc_solver</code> for
MWCS/GMWCS/SGMWCS;</li>
<li>heuristic simulated annealing solver <code>annealing_solver</code>
for MWCS/GMWCS/SGMWCS;</li>
<li>exact (if CPLEX library is available) or heuristic (without CPLEX)
solver <code>virgo_solver</code> for MWCS/GMWCS/SGMWCS.</li>
<li>exact SCIP-Jack (if SCIP is available) solver
<code>scipjack_solver</code> for MWCS;</li>
</ul>
<p>While selecting a particular solver depends on the particular class
of instances, the general recommendations are:</p>
<ul>
<li>For MWCS use <code>rmwcs_solver</code> if small suboptimality can be
tolerated. It is very fast and usually is able to find optimal or very
close to optimal solution. To find exact solution
<code>virgo_solver</code> can be used if CPLEX library is
available.</li>
<li>For Budget MWCS only <code>rmwcs_solver</code> is available.</li>
<li>For GMWCS and SGMWCS <code>virgo_solver</code> is the recommended
solver if CPLEX library is available. Without CPLEX it is recommended to
use <code>rnc_solver</code> giving both acceptable primal solution and
an upper bound on the objective function. Manual tuning of the
<code>annealing_solver</code> may give better solutions in some
cases.</li>
</ul>
<div id="rmwcs-solver" class="section level3">
<h3>Rmwcs solver</h3>
<p>Relax-and-cut solver is a heuristic solver able to rapidly find
high-quality solutions for MWCS problem (Alvarez-Miranda and Sinnl,
2017, <a href="https://doi.org/10.1016/j.cor.2017.05.015" class="uri">https://doi.org/10.1016/j.cor.2017.05.015</a>). The solver
does not require any additional libraries.</p>
<p>Relax-and-cut solver can be constructed using
<code>rmwcs_solver</code> function with the default arguments.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>rmwcs <span class="ot">&lt;-</span> <span class="fu">rmwcs_solver</span>()</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>m <span class="ot">&lt;-</span> <span class="fu">solve_mwcsp</span>(rmwcs, mwcs_example)</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(m<span class="sc">$</span>weight)</span></code></pre></div>
<pre><code>## [1] 1178.432</code></pre>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(m<span class="sc">$</span>solved_to_optimality)</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p><code>rmwcs_solver</code> supports Budget MWCS instances and its
special case where all budget costs are set to one and called MWCS with
cardinality constraints. In <code>mwcsr</code> such problems are
represented as Simple MWCS problems and maximum cardinality is passed to
<code>solve_mwcsp</code> funciton as argument:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a> m <span class="ot">&lt;-</span> <span class="fu">solve_mwcsp</span>(rmwcs, mwcs_example, <span class="at">max_cardinality =</span> <span class="dv">10</span>)</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a> <span class="fu">print</span>(<span class="fu">vcount</span>(m<span class="sc">$</span>graph))</span></code></pre></div>
<pre><code>## [1] 10</code></pre>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a> <span class="fu">print</span>(m<span class="sc">$</span>weight)</span></code></pre></div>
<pre><code>## [1] 134.9068</code></pre>
<p>To solve Budget MWCS passing budget limit is necessary as well:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a> m <span class="ot">&lt;-</span> <span class="fu">solve_mwcsp</span>(rmwcs, budget_mwcs_example, <span class="at">budget =</span> <span class="dv">10</span>)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a> <span class="fu">print</span>(<span class="fu">sum</span>(<span class="fu">V</span>(m<span class="sc">$</span>graph)<span class="sc">$</span>budget_cost))</span></code></pre></div>
<pre><code>## [1] 4.625048</code></pre>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a> <span class="fu">print</span>(m<span class="sc">$</span>weight)</span></code></pre></div>
<pre><code>## [1] 163.6254</code></pre>
</div>
<div id="rnc-solver" class="section level3">
<h3>Rnc solver</h3>
<p>Rnc solver is another relax-and-cut solver made for GMWCS/SGMWCS
problems inspired by rmwcs solver. The solver does not require any
libraries as well. Although with <code>rnc_solver</code> it is possible
to solve MWCS problems, running <code>rmwcs_solver</code> for this type
of problems of this type is preferable. No budget and cardinality
variants are available.</p>
<p>The solver can be constructed using <code>rnc_solver</code>
function.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>  rnc <span class="ot">&lt;-</span> <span class="fu">rnc_solver</span>()</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>  m <span class="ot">&lt;-</span> <span class="fu">solve_mwcsp</span>(rnc, gmwcs_example)</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(m<span class="sc">$</span>weight)</span></code></pre></div>
<pre><code>## [1] 1295.815</code></pre>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(m<span class="sc">$</span>solved_to_optimality)</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p>And for SGMWCS instance:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>  rnc <span class="ot">&lt;-</span> <span class="fu">rnc_solver</span>()</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>  m <span class="ot">&lt;-</span> <span class="fu">solve_mwcsp</span>(rnc, sgmwcs_example)</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(m<span class="sc">$</span>weight)</span></code></pre></div>
<pre><code>## [1] 263.8406</code></pre>
</div>
<div id="simulated-annealing-solver" class="section level3">
<h3>Simulated annealing solver</h3>
<p>Another heuristic solver is a simulated annealing based solver. The
solver is rather generic, but can produce good enough solutions if
parameters are tuned well. As it is heuristic solver with no estimate on
upper bound of the objective function the solved to optimality flag is
always set to <code>FALSE</code>.</p>
<p>This solver does support warm start allowing to run series of
restarts of annealing solver with different temperature schedules.</p>
<p>The use of this solver may be beneficial in some cases, although
there are no generic guidelines.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>m <span class="ot">&lt;-</span> <span class="cn">NULL</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">0</span><span class="sc">:</span><span class="dv">15</span>) {</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>  asolver <span class="ot">&lt;-</span> <span class="fu">annealing_solver</span>(<span class="at">schedule =</span> <span class="st">&quot;boltzmann&quot;</span>, <span class="at">initial_temperature =</span> <span class="fl">8.0</span> <span class="sc">/</span> (<span class="dv">2</span> <span class="sc">**</span> i),</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>                                <span class="at">final_temperature =</span> <span class="dv">1</span> <span class="sc">/</span> (<span class="dv">2</span> <span class="sc">**</span> i))</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (i <span class="sc">!=</span> <span class="dv">0</span>) {</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>    m <span class="ot">&lt;-</span> <span class="fu">solve_mwcsp</span>(asolver, gmwcs_example, <span class="at">warm_start =</span> m)</span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>    m <span class="ot">&lt;-</span> <span class="fu">solve_mwcsp</span>(asolver, gmwcs_example)</span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(m<span class="sc">$</span>weight)</span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<pre><code>## [1] 955.6224
## [1] 1157.73
## [1] 1216.681
## [1] 1218.817
## [1] 1222.339
## [1] 1222.339
## [1] 1222.339
## [1] 1222.339
## [1] 1222.339
## [1] 1222.339
## [1] 1222.339
## [1] 1222.339
## [1] 1222.339
## [1] 1222.339
## [1] 1222.339
## [1] 1222.339</code></pre>
</div>
<div id="java-based-virgo-solver" class="section level3">
<h3>Java-based Virgo solver</h3>
<p>The <code>mwcsr</code> package provides interface to exact Java-based
Virgo solver<br />
(<a href="https://github.com/ctlab/virgo-solver" class="uri">https://github.com/ctlab/virgo-solver</a>) which can be used
to solve MWCS, GMWCS and SGMWCS instances. The solver requires Java
(11+) to be installed on your machine.</p>
<p>There are two modes of execution:</p>
<ol style="list-style-type: decimal">
<li>Heuristic – which finds a solution based on minimal spanning tree
heuristic and does not require any additional setup;</li>
<li>Exact – which uses CPLEX library to solve the instances to provable
optimality. CPLEX can be downloaded from the official web-site: <a href="https://www.ibm.com/products/ilog-cplex-optimization-studio" class="uri">https://www.ibm.com/products/ilog-cplex-optimization-studio</a>.
Free licence can be obtained for academic purposes. CPLEX version 12.7.1
or higher is required.</li>
</ol>
<p>Heuristic solver can be constructed, by specifying
<code>cplex_dir=NULL</code>. As it is a heuristic solver, the solved to
optimality flag is always set to <code>FALSE</code>.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>mst_solver <span class="ot">&lt;-</span> <span class="fu">virgo_solver</span>(<span class="at">cplex_dir=</span><span class="cn">NULL</span>)</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>m <span class="ot">&lt;-</span> <span class="fu">solve_mwcsp</span>(mst_solver, sgmwcs_example)</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(m<span class="sc">$</span>weight)</span></code></pre></div>
<pre><code>## [1] 263.2752</code></pre>
<div class="sourceCode" id="cb63"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(m<span class="sc">$</span>solved_to_optimality)</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p>Exact solver requires setting <code>cplex_dir</code> argument with a
path to CPLEX installation. The <code>cplex_dir</code> requires, that
<code>cplex.jar</code> file and CPLEX dynamic library file (depending on
the operating system: <code>libcplex&lt;version&gt;.dll</code> for
Windows, <code>libcplex&lt;version&gt;.so</code> for Linux,
<code>libcplex&lt;version&gt;.jnilib</code> for OS X) can be found there
with recursive search. Alternatively, <code>cplex_jar</code> argument
pointing to <code>cplex.jar</code> file and <code>cplex_bin</code>
argument pointing to the directory with CPLEX dynamic library files can
be specified. Additionally, it is convenient to put the path to CPLEX
into a <code>CPLEX_HOME</code> environment variable, so that it does not
have to be changed from one system to another, when run.</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>cplex_dir <span class="ot">&lt;-</span> <span class="fu">Sys.getenv</span>(<span class="st">&#39;CPLEX_HOME&#39;</span>)</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>exact_solver <span class="ot">&lt;-</span> <span class="fu">virgo_solver</span>(<span class="at">cplex_dir=</span>cplex_dir)</span></code></pre></div>
<pre><code>## Error in virgo_solver(cplex_dir = cplex_dir): Could not find `cplex.jar` in /opt/ibm/ILOG/CPLEX_Studio129/</code></pre>
<div class="sourceCode" id="cb67"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>m <span class="ot">&lt;-</span> <span class="fu">solve_mwcsp</span>(exact_solver, sgmwcs_example)</span></code></pre></div>
<pre><code>## Error in check_mwcs_solver(solver): object &#39;exact_solver&#39; not found</code></pre>
<p>As the CPLEX found the optimal solution, the corresponding flag is
set to <code>TRUE</code>:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(m<span class="sc">$</span>weight)</span></code></pre></div>
<pre><code>## [1] 263.2752</code></pre>
<div class="sourceCode" id="cb71"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(m<span class="sc">$</span>solved_to_optimality)</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p>Some additional information like the running time, instance files,
solver version is available as in the <code>stats</code> field. Refer to
Virgo documentation for the description of the values.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(m<span class="sc">$</span>stats)</span></code></pre></div>
<pre><code>##   isOpt VPrep EPrep time nodes edges
## 1     0   136   148  478    59    58
##                                       nodefile
## 1 /tmp/RtmpvijSpS/graph442985f872ed5/nodes.txt
##                                       edgefile
## 1 /tmp/RtmpvijSpS/graph442985f872ed5/edges.txt
##                                          sigfile version
## 1 /tmp/RtmpvijSpS/graph442985f872ed5/signals.txt   0.1.5</code></pre>
<p>Computational resources availble for Virgo can be specified with the
following parameters:</p>
<ul>
<li><code>memory</code> – maximum amount of memory, more specifically
Java heap size, specified via <code>-Xmx</code> Java option, default:
<code>2G</code>.</li>
<li><code>threads</code> – number of threads for simultaneous
computation, default: the number of available cores.</li>
<li><code>timelimit</code> – maximum time in seconds to solve the
problem, if the solver is interrupted due to time limit, the best
solution found so far is reported and <code>solved_to_optimality</code>
flag is set to <code>FALSE</code>.</li>
</ul>
<p>Another useful parameter is <code>penalty</code>. The non-zero
penalty make the solver run an additional pass over the solution, with
each edge penalized with the specified value. As there can be multiple
solutions, having the same weight, especially in case of SGMWCS, this
procedure allows to locally minimize the solution size, while preserving
the weight.</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>psolver <span class="ot">&lt;-</span> <span class="fu">virgo_solver</span>(<span class="at">cplex_dir=</span>cplex_dir, <span class="at">penalty=</span><span class="fl">0.001</span>)</span></code></pre></div>
<pre><code>## Error in virgo_solver(cplex_dir = cplex_dir, penalty = 0.001): Could not find `cplex.jar` in /opt/ibm/ILOG/CPLEX_Studio129/</code></pre>
<div class="sourceCode" id="cb77"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>min_m <span class="ot">&lt;-</span> <span class="fu">solve_mwcsp</span>(psolver, sgmwcs_example)</span></code></pre></div>
<pre><code>## Error in check_mwcs_solver(solver): object &#39;psolver&#39; not found</code></pre>
<div class="sourceCode" id="cb79"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(min_m<span class="sc">$</span>weight)</span></code></pre></div>
<pre><code>## Error in print(min_m$weight): object &#39;min_m&#39; not found</code></pre>
<div class="sourceCode" id="cb81"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(min_m<span class="sc">$</span>stats)</span></code></pre></div>
<pre><code>## Error in print(min_m$stats): object &#39;min_m&#39; not found</code></pre>
<p>Now the solution, has <code>min_m$stats$nodes</code> nodes instead of
<code>m$stats$nodes</code> for the solution that was found before, while
having the same total weight of <code>min_m$weight</code>.</p>
</div>
<div id="scip-jack-solver" class="section level3">
<h3>SCIP-jack solver</h3>
<p>You can also use R interface to SCIP-jack solver. To use it you need
to download SCIPOptSuite from the <a href="https://scipopt.org/#scipoptsuite">official web-site</a> and build
<code>scipstp</code> application. Beware, that <code>scipstp</code> is
not provided in the pre-built SCIPOptSuite version, so you have to build
it manually from source.</p>
<p>Quick build instructions:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="co"># in scipoptsuite source directory</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="fu">cmake</span> <span class="at">-Bbuild</span> <span class="at">-H.</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a><span class="fu">cmake</span> <span class="at">--build</span> build <span class="at">--target</span> scipstp</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a><span class="co"># optionally copy scipstp file somewhere to $PATH</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a><span class="fu">cp</span> build/applications/scipstp /usr/local/bin/</span></code></pre></div>
<p>For complete build and configuration instructions for this solver
visit <a href="https://www.scipopt.org/doc/html/INSTALL_APPLICATIONS_EXAMPLES.php">SCIP</a>
website.</p>
<p>After installing and ensuring that scipstp application is correctly
built, you can access <code>scipjack_solver</code> class to solve MWCS
instances:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>scip <span class="ot">&lt;-</span> <span class="fu">scipjack_solver</span>(<span class="at">scipstp_bin=</span><span class="fu">Sys.which</span>(<span class="st">&quot;scipstp&quot;</span>))</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>sol <span class="ot">&lt;-</span> <span class="fu">solve_mwcsp</span>(scip, mwcs_example)</span></code></pre></div>
<p>The optimization parameters are passed using config file. You can
modify bundled file or create a new one to fine-tune the solver.</p>
</div>
</div>
<div id="integration-with-bionet" class="section level2">
<h2>Integration with BioNet</h2>
<p>This part of the tutorial shows how <code>mwcsr</code> solvers can be
combined with <code>BioNet</code> package to find an active module in a
protein-protein interaction network. You need <code>BioNet</code> and
<code>DLBCL</code> packages from Bioconductor to be installed in order
to run following code examples.</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>BioNetInstalled <span class="ot">&lt;-</span> <span class="cn">FALSE</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="fu">requireNamespace</span>(<span class="st">&quot;BioNet&quot;</span>) <span class="sc">&amp;&amp;</span> <span class="fu">requireNamespace</span>(<span class="st">&quot;DLBCL&quot;</span>)) {</span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>    BioNetInstalled <span class="ot">&lt;-</span> <span class="cn">TRUE</span>    </span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Let start with generating an example scored network, following BioNet
tutorial:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (BioNetInstalled) {</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">library</span>(<span class="st">&quot;BioNet&quot;</span>)</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">library</span>(<span class="st">&quot;DLBCL&quot;</span>)</span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">data</span>(dataLym)</span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">data</span>(interactome)</span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>    pvals <span class="ot">&lt;-</span> <span class="fu">cbind</span>(<span class="at">t =</span> dataLym<span class="sc">$</span>t.pval, <span class="at">s =</span> dataLym<span class="sc">$</span>s.pval)</span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">rownames</span>(pvals) <span class="ot">&lt;-</span> dataLym<span class="sc">$</span>label</span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a>    pval <span class="ot">&lt;-</span> <span class="fu">aggrPvals</span>(pvals, <span class="at">order =</span> <span class="dv">2</span>, <span class="at">plot =</span> <span class="cn">FALSE</span>)</span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a>    logFC <span class="ot">&lt;-</span> dataLym<span class="sc">$</span>diff</span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">names</span>(logFC) <span class="ot">&lt;-</span> dataLym<span class="sc">$</span>label</span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a>    subnet <span class="ot">&lt;-</span> <span class="fu">subNetwork</span>(dataLym<span class="sc">$</span>label, interactome)</span>
<span id="cb86-12"><a href="#cb86-12" aria-hidden="true" tabindex="-1"></a>    subnet <span class="ot">&lt;-</span> <span class="fu">rmSelfLoops</span>(subnet)</span>
<span id="cb86-13"><a href="#cb86-13" aria-hidden="true" tabindex="-1"></a>    fb <span class="ot">&lt;-</span> <span class="fu">fitBumModel</span>(pval, <span class="at">plot =</span> <span class="cn">FALSE</span>)</span>
<span id="cb86-14"><a href="#cb86-14" aria-hidden="true" tabindex="-1"></a>    scores <span class="ot">&lt;-</span> <span class="fu">scoreNodes</span>(subnet, fb, <span class="at">fdr =</span> <span class="fl">0.001</span>)</span>
<span id="cb86-15"><a href="#cb86-15" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Here we have network object <code>subnet</code> of type
<code>graphNEL</code> and a vector of node scores
<code>scores</code>:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (BioNetInstalled) {</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>    subnet</span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">str</span>(scores)</span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>BioNet comes with a heuristic MWCS FastHeinz solver, that we can use
to find the module following the BioNet tutorial:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (BioNetInstalled) {</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>    bionet_h <span class="ot">&lt;-</span> <span class="fu">runFastHeinz</span>(subnet, scores)</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">plotModule</span>(bionet_h, <span class="at">scores=</span>scores, <span class="at">diff.expr=</span>logFC)</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">sum</span>(scores[<span class="fu">nodes</span>(bionet_h)])</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>We can construct an MWCS instance by converting <code>graphNEL</code>
object into <code>igraph</code> and add node weights:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (BioNetInstalled) { </span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>    bionet_example <span class="ot">&lt;-</span> <span class="fu">igraph.from.graphNEL</span>(subnet, <span class="at">weight=</span><span class="cn">FALSE</span>) <span class="co"># ignoring edge weights of 1</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">V</span>(bionet_example)<span class="sc">$</span>weight <span class="ot">&lt;-</span> scores[<span class="fu">V</span>(bionet_example)]</span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">get_instance_type</span>(bionet_example)</span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Now the instance can be solved with the relax-and-cut solver:</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (BioNetInstalled) {</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>    rmwcs <span class="ot">&lt;-</span> <span class="fu">rmwcs_solver</span>()</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>    bionet_m <span class="ot">&lt;-</span> <span class="fu">solve_mwcsp</span>(rmwcs, bionet_example)</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">plotModule</span>(bionet_m<span class="sc">$</span>graph, <span class="at">scores=</span>scores, <span class="at">diff.expr=</span>logFC)</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Note that the weight increased, compared to FastHeinz solution:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (BioNetInstalled) {</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span>(bionet_m<span class="sc">$</span>weight)</span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Similarly, Virgo can be used to solve the instance to provable
optimality, but in this case it produces the same results:</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (BioNetInstalled) {</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>    bionet_m_exact <span class="ot">&lt;-</span> <span class="fu">solve_mwcsp</span>(exact_solver, bionet_example)</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span>(bionet_m_exact<span class="sc">$</span>weight)</span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span>(bionet_m_exact<span class="sc">$</span>solved_to_optimality)</span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
